local Strategy = require('strategy')

local STATE = {
	target = nil,
	targetingRange = 2000,
	firingRange = 1000,
	justDied = false,
	justKilled = false,
	personalSpace = 300
}

INPUTS = {
	{
		name = "health",
		measure = function()
			return bot:getHealth() or 0
		end
	},

	{
		name = "energy",
		measure = function()
			return bot:getEnergy() or 0
		end
	},

	{
		name = "targetHealth",
		measure = function()
			if STATE.target == nil then
				return 0
			end

			return STATE.target:getHealth() or 0
		end
	},

	{
		name = "canSeeTarget",
		measure = function()
			if STATE.target == nil or not STATE.target:getGeom() or not bot:canSeePoint(STATE.target:getGeom())then
				return 0
			end

			return 1
		end
	},

	{
		name = "haveTarget",
		measure = function()
			if (STATE.target == nil) or (STATE.target:getHealth() == nil) or (STATE.target:getHealth() <= 0) then
				return 0
			end

			return 1
		end
	},

	{
		name = "closestDangerousProjectile",
		measure = function()
			local botPos = bot:getPos()

			if not botPos then
				return 1
			end

			local offset = point.new(STATE.personalSpace, STATE.personalSpace)
			local projectiles = { }
			bf:findAllObjectsInArea(projectiles, botPos + offset, botPos - offset, ObjType.Bullet, ObjType.Burst, ObjType.Seeker)

			local closest = math.huge
			for _,projectile in pairs(projectiles) do
				if projectile:getOwner():getName() ~= bot:getPlayerInfo():getName() then
					closest = math.min(closest, point.distSquared(projectile:getPos(), botPos))
				end
			end

			return closest / math.pow(STATE.personalSpace, 2)
		end
	},
}

TARGETTING_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "target",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},
	
}

MOVEMENT_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "approach",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local targetPos = STATE.target:getPos()

			if STATE.target and targetPos then
				bot:setThrustToPt(bot:getWaypoint(targetPos) or botPos)
			end
		end
	},

	{
		name = "flee",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local targetPos = STATE.target:getPos()
			local botPos = bot:getPos()

			if STATE.target and botPos and targetPos then
				local offset = botPos - targetPos
				bot:setThrustToPt(bot:getWaypoint(botPos + offset) or botPos)
			end
		end
	},
}

WEAPONS_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "phaser",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local solution = bot:getFiringSolution(STATE.target)

			if solution then
				bot:setAngle(solution)
				bot:fireWeapon(Weapon.Phaser)
			end
		end
	},

	{
		name = "burst",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local solution = bot:getFiringSolution(STATE.target)

			if solution then
				bot:setAngle(solution)
				bot:fireWeapon(Weapon.Burst)
			end
		end
	},
	
}

SHIELD_ACTIONS = {
	{
		name = "nothing",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},

	{
		name = "activate",
		enact = function()
			bot:fireModule(Module.Shield)
		end
	},
	
}

BOOST_ACTIONS = {
	{
		name = "nothing",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},

	{
		name = "activate",
		enact = function()
			bot:fireModule(Module.Turbo)
		end
	},
	
}

PLAN_INTERVAL = 100
NEXT_PLAN_TIME = 0

local STRATEGIES = {
	Strategy.create('weapons',    #INPUTS, WEAPONS_ACTIONS),
	Strategy.create('targetting', #INPUTS, TARGETTING_ACTIONS),
	Strategy.create('movement',   #INPUTS, MOVEMENT_ACTIONS),
	Strategy.create('shield',     #INPUTS, SHIELD_ACTIONS),
	Strategy.create('boost',      #INPUTS, BOOST_ACTIONS),
}

function main()
	subscribe(Event.MsgReceived)
	subscribe(Event.ScoreChanged)
end

function getName()
	return 'BrainBot'
end

function onMsgReceived()
	logprint('debugging!')
end

local lastWrite = 0
local start = getMachineTime()
function onScoreChanged(scoreChange, teamIndex, player) 
	if getMachineTime() > lastWrite then
		lastWrite = getMachineTime()
		for i,strategy in ipairs(STRATEGIES) do
			strategy:save()
		end
	end

	if player == bot:getPlayerInfo() and scoreChange > 0 then
		STATE.justKilled = true
	elseif player ~= bot:getPlayerInfo() and scoreChange > 0 or
	       player == bot:getPlayerInfo() and scoreChange < 0 then
		STATE.justDied = true
	end
end

local clock = 0
local deaths = 0
local kills = 0
local record = { }
local RECORD_STATES = 20
function onTick(dt)
	clock = clock + dt

	if bot:getHealth() <= 0 then
		return
	end

	if clock > NEXT_PLAN_TIME then

		local currentInputs = getInputs()
		for k,v in pairs(STRATEGIES) do
			v:plan(currentInputs)
		end

		local reinforcement = 0
		if STATE.justKilled then
			-- logprint('killed')
			kills = kills + 1
			table.insert(record, true)
			reinforcement = 1
		elseif STATE.justDied then
			-- logprint('died')
			deaths = deaths + 1
			table.insert(record, false)
			reinforcement = -1
		end

		if #record > RECORD_STATES then
			table.remove(record, 1)
		end

		if reinforcement ~= 0 then
			logprint('kills '..kills)
			logprint('deaths '..deaths)
			local k, d = 0, 0
			for i,v in ipairs(record) do
				if v then
					k = k + 1
				else
					d = d + 1
				end
			end
			writeToFile("record", tostring(k / d).."\n", true)
			logprint(k/d)

			for k,v in pairs(STRATEGIES) do
				v:learn(reinforcement)
			end
		end

		STATE.justDied = false
		STATE.justKilled = false

		NEXT_PLAN_TIME = clock + PLAN_INTERVAL
	end

	for k,v in pairs(STRATEGIES) do
		v:enact()
	end
end

function getInputs()
	local result = { }

	for i,input in ipairs(INPUTS) do
		local v = input.measure()
		result[input.name] = v
		result[i] = v
	end

	return result
end