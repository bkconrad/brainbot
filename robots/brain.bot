local Strategy = require('strategy')
local RECORD_STATES = 20

local VERBOSITY = 0
local EXPERIMENT = true
local function v(...)
	if VERBOSITY >= 1 then
		logprint(unpack(arg))
	end
end

local function vv(...)
	if VERBOSITY >= 2 then
		logprint(unpack(arg))
	end
end

local argumentHandlers = {
	verbose = function() VERBOSITY=1 ; Strategy.verbosity = VERBOSITY end,
	vverbose = function() VERBOSITY=2 ; Strategy.verbosity = VERBOSITY end,
	experiment = function()
		EXPERIMENT = not EXPERIMENT
		if EXPERIMENT then
			logprint('experiment on')
		else
			logprint('experiment off')
		end
	end
}

local deaths = 0
local kills = 0
local record = { }
local recordrecord = { }

local STATE = {
	target = nil,
	targetingRange = 2000,
	firingRange = 1000,
	justDied = false,
	justKilled = false,
	personalSpace = 300,
	repairItemTarget = nil
}

INPUTS = {
	{
		name = "health",
		measure = function()
			return bot:getHealth() or 0
		end
	},

	{
		name = "energy",
		measure = function()
			return bot:getEnergy() or 0
		end
	},

	{
		name = "targetHealth",
		measure = function()
			if STATE.target == nil then
				return 0
			end

			return STATE.target:getHealth() or 0
		end
	},

	{
		name = "canSeeTarget",
		measure = function()
			if STATE.target == nil or not STATE.target:getGeom() or not bot:canSeePoint(STATE.target:getGeom())then
				return 0
			end

			return 1
		end
	},

	{
		name = "haveTarget",
		measure = function()
			if (STATE.target == nil) or (STATE.target:getHealth() == nil) or (STATE.target:getHealth() <= 0) then
				return 0
			end

			return 1
		end
	},

	{
		name = "closestDangerousProjectile",
		measure = function()
			local botPos = bot:getPos()

			if not botPos then
				return 1
			end

			local offset = point.new(STATE.personalSpace, STATE.personalSpace)
			local projectiles = { }
			bf:findAllObjectsInArea(projectiles, botPos + offset, botPos - offset, ObjType.Bullet, ObjType.Burst, ObjType.Seeker)

			local me = bot:getPlayerInfo():getName()
			local closest = math.huge
			for _,projectile in pairs(projectiles) do

				local objType = projectile:getObjType()
				if
					projectile:getOwner():getName() ~= me or -- A projectile we don't own
					objType == ObjType.Mine               or -- Any exploding type
					objType == ObjType.Seeker             or
					objType == ObjType.Burst
				then
					closest = math.min(closest, point.distSquared(projectile:getPos(), botPos))
				end
			end

			return math.min(1.0, closest / math.pow(STATE.personalSpace, 2))
		end
	},

	{
		name = "closestRepairItem",
		measure = function()
			local botPos = bot:getPos()

			if not botPos then
				return 1
			end

			local repairItems = { }
			bf:findAllObjects(repairItems, ObjType.RepairItem)

			local closest = math.huge
			STATE.repairItemTarget = nil
			for _,repairItem in pairs(repairItems) do
				local distSquared = math.min(closest, point.distSquared(repairItem:getPos(), botPos))
				if repairItem:isVis() and distSquared < closest then
					STATE.repairItemTarget = repairItem
				end
			end

			if closest == math.huge then return 1.0 end

			return closest / math.pow(STATE.targetingRange, 2)
		end
	},
}

TARGETTING_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "target",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},
	
}

MOVEMENT_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "approach",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local targetPos = STATE.target:getPos()

			if STATE.target and targetPos then
				bot:setThrustToPt(bot:getWaypoint(targetPos) or botPos)
			end
		end
	},

	{
		name = "flee",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local targetPos = STATE.target:getPos()
			local botPos = bot:getPos()

			if STATE.target and botPos and targetPos then
				local offset = botPos - targetPos
				bot:setThrustToPt(bot:getWaypoint(botPos + offset) or botPos)
			end
		end
	},

	{
		name = "repair",
		enact = function()
			if bot == nil or STATE.repairItemTarget == nil then
				return
			end

			local targetPos = STATE.repairItemTarget:getPos()
			local botPos = bot:getPos()

			if botPos and targetPos then
				bot:setThrustToPt(bot:getWaypoint(targetPos) or botPos)
			end
		end
	},
}

WEAPONS_ACTIONS = {
	{
		name = "nothing",
		enact = function()
		end
	},

	{
		name = "phaser",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local solution = bot:getFiringSolution(STATE.target)

			if solution then
				bot:setAngle(solution)
				bot:fireWeapon(Weapon.Phaser)
			end
		end
	},

	{
		name = "triple",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local solution = bot:getFiringSolution(STATE.target)

			if solution then
				bot:setAngle(solution)
				bot:fireWeapon(Weapon.Triple)
			end
		end
	},

	{
		name = "burst",
		enact = function()
			if bot == nil or STATE.target == nil then
				return
			end

			local solution = bot:getFiringSolution(STATE.target)

			if solution then
				bot:setAngle(solution)
				bot:fireWeapon(Weapon.Burst)
			end
		end
	},
	
}

SHIELD_ACTIONS = {
	{
		name = "nothing",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},

	{
		name = "activate",
		enact = function()
			bot:fireModule(Module.Shield)
		end
	},
	
}

BOOST_ACTIONS = {
	{
		name = "nothing",
		enact = function()
			STATE.target = bot:findClosestEnemy(STATE.targetingRange)
		end
	},

	{
		name = "activate",
		enact = function()
			bot:fireModule(Module.Turbo)
		end
	},
	
}

PLAN_INTERVAL = 100
NEXT_PLAN_TIME = 0

local STRATEGIES = {
	Strategy.create('weapons',    #INPUTS, WEAPONS_ACTIONS),
	Strategy.create('targetting', #INPUTS, TARGETTING_ACTIONS),
	Strategy.create('movement',   #INPUTS, MOVEMENT_ACTIONS),
	Strategy.create('shield',     #INPUTS, SHIELD_ACTIONS),
	Strategy.create('boost',      #INPUTS, BOOST_ACTIONS),
}

function main()
	for i=1,#arg do
		for k,handler in pairs(argumentHandlers) do
			if string.find(k, arg[i]) == 1 then
				handler()
			end
		end
	end
	subscribe(Event.MsgReceived)
	subscribe(Event.ScoreChanged)

	bot:setLoadoutNow(Weapon.Phaser, Weapon.Triple, Weapon.Burst, Module.Shield, Module.Turbo)
end

function getName()
	return 'BrainBot'
end

function onMsgReceived()
	logprint('debugging!')
end

local gStrategyToTrain = 1
function onScoreChanged(scoreChange, teamIndex, player) 

	local reinforcement = -1
	if player == bot:getPlayerInfo() and scoreChange > 0 then
		reinforcement = 1
	elseif player ~= bot:getPlayerInfo() and scoreChange > 0 or
	       player == bot:getPlayerInfo() and scoreChange < 0 then
		reinforcement = 0
	end

	if reinforcement == 1 then
		kills = kills + 1
		table.insert(record, true)
	elseif reinforcement == 0 then
		deaths = deaths + 1
		table.insert(record, false)
	end

	if #record > RECORD_STATES then
		table.remove(record, 1)
	end

	if EXPERIMENT and reinforcement ~= -1 then
		v('kills '..kills)
		v('deaths '..deaths)
		local k, d = 0, 0
		for i,v in ipairs(record) do
			if v then
				k = k + 1
			else
				d = d + 1
			end
		end
		local kdr = k / d
		if kdr == math.huge then kdr = k end

		table.insert(recordrecord, kdr)

		if #recordrecord > RECORD_STATES then
			writeToFile("record", table.concat(recordrecord,"\n").."\n", true)
			recordrecord = { }
		end
		vv(k/d)

		-- Only train one strategy at a time. Training more than one introduces
		-- noise because the stratgy's performance (and therefore learning)
		-- depends on the performance of all the strategies as a whole.
		STRATEGIES[gStrategyToTrain]:learn(reinforcement)

		-- move to the next strategy
		gStrategyToTrain = gStrategyToTrain + 1
		if gStrategyToTrain > #STRATEGIES then
			gStrategyToTrain = 1
		end
	end
end

local clock = 0
function onTick(dt)
	clock = clock + dt

	if bot:getHealth() <= 0 then
		return
	end

	if clock > NEXT_PLAN_TIME then

		local currentInputs = getInputs()
		for i,v in ipairs(STRATEGIES) do
			-- Only allow experimentation for the strategy currently being trained
			v:plan(currentInputs, EXPERIMENT and i == gStrategyToTrain)
		end

		NEXT_PLAN_TIME = clock + PLAN_INTERVAL
	end

	for i,v in ipairs(STRATEGIES) do
		v:enact()
	end
end

function getInputs()
	local result = { }

	for i,input in ipairs(INPUTS) do
		local v = input.measure()
		result[input.name] = v
		result[i] = v
	end

	return result
end